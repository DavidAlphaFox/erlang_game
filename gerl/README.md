gerl
=====

gerl是一个ARPG类游戏的服务端实现，具体的说明请参见我的印象笔记。

### 代码风格约定： 

* 数据库中的表命名规范：**tab_xxx**
* 配置文件都放在config目录下，文件名以**cfg_xxx.erl**格式命令，里面用到的record以**c_xxx**命名
* 协议中定义的record以**m_xxx**命令
* 代码中定义的record以**r_xxx**命名

### 地图id格式：
* 格式：地图类型 + 子id，5位数
* 地图类型（10-99）：城镇、多人大型副本、组队副本、单人副本
* 子id为3位数：000-999

### 服务器的启动配置：
* 启动配置位于run_setting目录下
* 不同的服是以一个数字编号来标识的，N服的配置就为：gerl_settingN.erl
* N服的N参数是通过启动脚本中传递的启动参数来的
* 启动配置里可以配置各个节点中需要启动哪些app，以及哪些地图归属于哪个节点的
* 具体启动多少个节点是由启动脚本来确定的

### 协议号定义规则：
* 格式：协议簇 + 子id，共5位数
* 子id：000-999
* 协议簇：10-99
	* 10：登陆
	* 11：场景

### 协议命名规则：
* ms_协议簇名_其他：客户端 --> 服务端
* mc_协议簇名_其他：服务端 --> 客户端

### 协议生成：
* 协议定义文件放在proto目录下，按协议簇来分类不同的proto文件
* 使用工具erlang_protobuffs来生成协议的头文件的，生成的源文件我暂时没有使用
* erlang_protobuffs只支持int等内置数据类型的，我暂时屏蔽了protobuffs_compile.erl中的找不到类型时的报错，修改在is_scalar_type/1方法里

### error code的定义：
* 类似如此定义：-define(ERR_BAG_INSUFFICIENT,		1001)
* 即：ERR_CLASSIFY_WHY，CLASSIFY为分类，WHY为原因
* 错误号：每个分类占据001-999，分类编号为ERROR_CODE div 1000
* 当一个方法失败要返回的格式应为：{error, ?ERROR_CODE}
